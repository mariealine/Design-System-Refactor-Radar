/**
 * Template: Design System Compliance Rule
 *
 * Generates a markdown rule file for AI assistants (Cursor, Claude, Agents)
 * based on the ds-coverage config. This ensures the AI enforces the same
 * rules the scanner detects.
 *
 * Fully agnostic — works with any CSS methodology and framework.
 */

import type { DsCoverageConfig } from "../config.js";

export function generateComplianceRule(config: DsCoverageConfig): string {
  const api = config.componentAnalysis.api;
  const primaryDir = config.componentAnalysis.primaryDirectory;
  const legacyDirs = config.componentAnalysis.legacyDirectories;
  const hasComponentAnalysis = config.componentAnalysis.enabled;

  // Build violation checklist from config (dynamic — no hardcoded examples)
  const enabledViolations = Object.entries(config.violations).filter(([, v]) => v.enabled);

  const violationChecklist = enabledViolations
    .map(([, v]) => `- **${v.label}** ${v.icon} — Do not hardcode. Use semantic design tokens.`)
    .join("\n");

  // Build prop section only if component analysis is enabled
  const propSection = hasComponentAnalysis
    ? buildPropSection(config)
    : "";

  // Build size section only if sizes are defined
  const sizeSection =
    hasComponentAnalysis && api.expectedSizes.length > 0
      ? buildSizeSection(config)
      : "";

  const forbiddenPropsNote =
    hasComponentAnalysis && api.forbiddenProps.length > 0
      ? `\n\n**Forbidden prop names** (legacy): ${api.forbiddenProps.map((p) => `\`${p}\``).join(", ")}. Must be migrated to the names above.`
      : "";

  // Build component decision hierarchy only if component analysis is enabled
  const componentHierarchy = hasComponentAnalysis
    ? buildComponentHierarchy(config)
    : "";

  // Build non-compliant section from actual config
  const nonCompliantList = enabledViolations
    .map(([, v]) => `- ${v.icon} **${v.label}**: Hardcoded values detected by the scanner`)
    .join("\n");

  return `---
description: Design system compliance protocol — applies to all frontend work
globs: ${config.scanDir}/**/*
---

# Design System Compliance Protocol

## Applies to
All frontend work in \`${config.scanDir}/\`.

## Rule

This rule defines the **decision framework** for building UI. It ensures visual consistency through component reuse, systematic flagging, and incremental refactoring.

> **This rule is auto-generated by ds-coverage.** It stays in sync with the scanner config so that the AI assistant enforces the same rules the scanner detects.

---

## CRITICAL — New Code Requirements

**Every line of frontend code MUST be design-system compliant from the start.** This is non-negotiable — zero tolerance for introducing new design debt.

Before writing UI code, check:
${violationChecklist}
${hasComponentAnalysis ? `- **Components** → Does a component already exist in \`${primaryDir}\`? **Use it.** ${legacyDirs.length > 0 ? `Also check legacy directories (${legacyDirs.map((d) => `\`${d}\``).join(", ")}) — but new components MUST go in \`${primaryDir}\`.` : ""}` : ""}

**If this rule is not followed, the code must be rejected.**

---
${componentHierarchy}
${propSection}${forbiddenPropsNote}
${sizeSection}

---

## Flagging Conventions

Three types of flags for annotating code:

### \`@ds-migrate: simple\`
A direct swap. Can be done inline by any developer or AI assistant.

\`\`\`
// @ds-migrate: simple | Replace hardcoded value with semantic token
\`\`\`

### \`@ds-migrate: complex\`
A migration requiring dedicated effort. Include: what to migrate, risks, cost estimate, and constraints.

\`\`\`
// @ds-migrate: complex | This custom component should use the DS component.
// Risks: Custom keyboard navigation logic might conflict.
// Cost: ~2h refactor, check all usages.
\`\`\`

### \`@ds-todo\`
A missing component or token that should be added to the design system.

\`\`\`
// @ds-todo: Create <ComponentName> — rationale
\`\`\`

---

## Boy Scout Rule Protocol

When editing a file in \`${config.scanDir}/\`:

1. **Scan the code you touch** (the function, component, or block you're modifying)
2. **Apply unambiguous migrations immediately**: 1:1 token swaps with a clear semantic match
3. **When multiple semantic tokens could match**, **propose options to the developer** with context explaining the semantic meaning of each candidate. Provide visual context when possible:
   - **(a) Take a screenshot** via browser tools if available
   - **(b) Ask the developer for a screenshot**, giving the navigation path
   - **(c) Describe visually** what the component looks like as a last resort
4. **Flag complex migrations**: Don't silently refactor large patterns — add \`@ds-migrate: complex\`
5. **Flag missing components**: If you spot a repeated pattern, add \`@ds-todo\`
6. **Never break existing behavior**: Migrations must be visual only. Same look, same interactions.

---

## What is "non-compliant"

Any of these in code you're editing should be flagged or fixed:

${nonCompliantList}
${hasComponentAnalysis ? `- Native HTML elements (\`<button>\`, \`<input>\`, \`<select>\`) when a UI component exists\n- Duplicated UI patterns that should be a component` : ""}
${hasComponentAnalysis && api.forbiddenProps.length > 0 ? api.forbiddenProps.map((p) => `- Legacy prop name \`${p}\``).join("\n") : ""}
${hasComponentAnalysis && api.forbiddenSizes.length > 0 ? `- Legacy size values: ${api.forbiddenSizes.map((s) => `\`${s}\``).join(", ")}` : ""}

---

## Refactoring Workflow

For dedicated refactoring sessions:

1. **Find flags**: Search for \`@ds-migrate\` and \`@ds-todo\` in the codebase
2. **Run the scanner**: \`npx ds-coverage\` — open the dashboard to see violations
3. **Prioritize**:
   - \`@ds-migrate: simple\` → batch and apply (quick wins)
   - \`@ds-todo\` → create the missing DS components
   - \`@ds-migrate: complex\` → plan as dedicated tasks
4. **Verify**: After migration, test visually
5. **Clean up**: Remove the flag comment after migration
6. **Re-scan**: Re-run \`npx ds-coverage\` to verify improvements
`;
}

// ============================================
// SECTION BUILDERS
// ============================================

function buildComponentHierarchy(config: DsCoverageConfig): string {
  const primaryDir = config.componentAnalysis.primaryDirectory;
  const legacyDirs = config.componentAnalysis.legacyDirectories;
  const api = config.componentAnalysis.api;

  const architectureNote = api.requireCVA
    ? "- Use CVA for variants\n"
    : "";

  return `
## Decision Hierarchy (follow in order)

### 1. Use an existing UI component
Check \`${primaryDir}\` first. If a component exists that fits the need, **use it**. Don't recreate buttons, badges, inputs, dialogs, selects, etc.
${legacyDirs.length > 0 ? `\n> **Note:** Some components still live in legacy directories (${legacyDirs.map((d) => `\`${d}\``).join(", ")}). Check there too, but new components always go in \`${primaryDir}\`.` : ""}

### 2. Create a new UI component
If no existing component fits, create one in \`${primaryDir}\`. The component MUST:
${architectureNote}- Use semantic design tokens exclusively
- Have a simple, concise name (1-2 words)
- Follow the prop conventions below

### 3. Last resort: inline code with tokens
If you need a one-off layout that doesn't justify a component, you can write inline code — but you MUST use semantic tokens. Flag if the pattern could be reusable:

\`\`\`
// @ds-todo: Consider creating a component if this pattern repeats
\`\`\`
`;
}

function buildPropSection(config: DsCoverageConfig): string {
  const api = config.componentAnalysis.api;

  if (api.expectedProps.length === 0) return "";

  return `
---

## Prop Naming Conventions

All design system components use these **standardized prop names**:

### Expected variant props: ${api.expectedProps.map((p) => `\`${p}\``).join(", ")}
`;
}

function buildSizeSection(config: DsCoverageConfig): string {
  const api = config.componentAnalysis.api;

  const sizeTable = api.expectedSizes
    .map((size) => `| \`${size}\` |`)
    .join("\n");

  const forbiddenSizesList = api.forbiddenSizes.length > 0
    ? api.forbiddenSizes.map((s) => `\`${s}\``).join(", ")
    : "";

  return `
### \`size\` prop — expected values
| Accepted values |
|-----------------|
${sizeTable}
${forbiddenSizesList ? `\n**Forbidden** (legacy abbreviations): ${forbiddenSizesList}` : ""}
`;
}
