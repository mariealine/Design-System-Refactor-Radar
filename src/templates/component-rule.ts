/**
 * Template: UI Component Creation Standards
 *
 * Generates a markdown rule for how to create new UI components
 * following design system patterns.
 *
 * Fully agnostic — adapts to the configured component architecture.
 */

import type { DsCoverageConfig } from "../config.js";

export function generateComponentRule(config: DsCoverageConfig): string {
  const api = config.componentAnalysis.api;
  const primaryDir = config.componentAnalysis.primaryDirectory;
  const legacyDirs = config.componentAnalysis.legacyDirectories;

  const sizeList = api.expectedSizes
    .map((size) => `  - \`${size}\``)
    .join("\n");

  const forbiddenSizeNote = api.forbiddenSizes.length > 0
    ? `\n\n**Forbidden** (legacy abbreviations): ${api.forbiddenSizes.map((s) => `\`${s}\``).join(", ")}`
    : "";

  // Build architecture section based on config
  const architectureSection = buildArchitectureSection(config);

  return `---
description: UI component creation standards — applies when creating or modifying components
globs: ${primaryDir}**/*
---

# UI Component Creation Standards

## Applies to
Files in \`${primaryDir}\`.

## Rule

Every UI component MUST follow the design system architecture. UI components are the **atomic building blocks** — they must be generic, reusable, and design-system compliant.

> **This rule is auto-generated by Design System Refactor Radar.** Update your \`design-system-refactor-radar.config\` and re-run \`npx design-system-refactor-radar init --force\` to regenerate.

---

## Component Location

**All reusable components live in a single directory:**

\`\`\`
${primaryDir}    ← ALL design system components
\`\`\`
${legacyDirs.length > 0 ? `\n> **Note:** Legacy components may exist in ${legacyDirs.map((d) => `\`${d}\``).join(", ")}. When editing them, flag for migration to \`${primaryDir}\` with \`@ds-migrate: complex\` if appropriate. New components MUST always go in \`${primaryDir}\`.\n` : ""}
---

## Creating a New UI Component

### 1. Naming
- **Simple and concise**: \`Badge\`, \`Card\`, \`Toggle\` — not \`StatusIndicatorBadge\`
- **One word if possible**, two words max
- **No parent-child naming**: Each component is standalone
- **File name** = component name: \`badge.tsx\` → \`Badge\`

${architectureSection}

### 3. Design Token Compliance

- **ALL colors**: Must use semantic tokens — zero hardcoded values
- **ALL radii**: Must use token values
- **ALL text styles**: Must use the DS typography system
- **NO** hardcoded colors, hex values, or raw utility classes for visual properties

### 4. API Design — Prop Names

Use these **standardized prop names** across all components:
${api.expectedProps.map((p) => `- **\`${p}\`**`).join("\n")}
- **\`className\`** — always accepted for composition (if applicable to the framework)
- **\`disabled\`** — for interactive components

**\`size\` values**:
${sizeList}${forbiddenSizeNote}

${api.forbiddenProps.length > 0 ? `**Forbidden prop names** (legacy — must be migrated):\n${api.forbiddenProps.map((p) => `- \`${p}\``).join("\n")}` : ""}

### 5. Accessibility

- Use \`focus-visible\` (not \`focus\`) for keyboard-only focus rings
- Include appropriate ARIA attributes
- Disabled states: both visual and functional

### 6. Checklist Before Merging a New UI Component

- [ ] All visual properties use semantic tokens (zero hardcoded values)
- [ ] Has a \`className\` prop for composition (if applicable)
- [ ] Simple, concise naming (1-2 words)
- [ ] Consistent API with existing components (${api.expectedProps.join(", ")})
- [ ] focus-visible states defined
- [ ] Disabled states defined (if interactive)
${api.requireCVA ? "- [ ] Uses CVA for variants\n" : ""}${api.requireRadix ? "- [ ] Supports `asChild` via Radix Slot\n" : ""}`;
}

// ============================================
// ARCHITECTURE SECTION BUILDER
// ============================================

function buildArchitectureSection(config: DsCoverageConfig): string {
  const api = config.componentAnalysis.api;

  if (api.requireCVA) {
    return buildCVAArchitecture(config);
  }

  // Generic architecture (no specific library)
  return `### 2. Architecture

Every UI component should follow a consistent structure:

- **Variants via props**: Define visual variations (${api.expectedProps.map((p) => `\`${p}\``).join(", ")}) as typed props
- **Semantic tokens only**: No hardcoded values in styles
- **Default values**: Defined in the function/component signature
- **Composition**: Accept \`className\` (or equivalent) to allow customization
- **Strict typing**: All variant props are typed with unions/enums

\`\`\`
// Generic structure example
// Adapt to your framework and CSS methodology

interface ComponentProps {
${api.expectedProps.map((p) => `  ${p}?: string;`).join("\n")}
  className?: string;
  children?: any;
}

// Map variant combinations to styles
// via semantic tokens (CSS classes, CSS variables, etc.)
\`\`\``;
}

function buildCVAArchitecture(config: DsCoverageConfig): string {
  const api = config.componentAnalysis.api;

  const sizeVariants = api.expectedSizes
    .map((s) => `        ${s}: "",`)
    .join("\n");

  return `### 2. Architecture (CVA${api.requireRadix ? " + Radix" : ""})

\`\`\`tsx
import { cva, type VariantProps } from "class-variance-authority";${api.requireRadix ? '\nimport { Slot } from "radix-ui";' : ""}

const componentVariants = cva(
  // Base classes — semantic tokens only
  "base-styles-here",
  {
    variants: {${api.expectedProps.filter((p) => p !== "size").map((p) => `
      ${p}: {
        // Define values for ${p}
      },`).join("")}${api.expectedProps.includes("size") ? `
      size: {
${sizeVariants}
      },` : ""}
    },${api.expectedProps.filter((p) => !["size"].includes(p)).length >= 2 ? `
    compoundVariants: [
      // Combine variants for precise styles
    ],` : ""}
  },
);

function MyComponent({
  className,${api.expectedProps.map((p) => `\n  ${p},`).join("")}${api.requireRadix ? "\n  asChild = false," : ""}
  ...props
}: ComponentProps & VariantProps<typeof componentVariants>) {${api.requireRadix ? '\n  const Comp = asChild ? Slot : "div";' : ""}
  return (
    <${api.requireRadix ? "Comp" : "div"}
      className={cn(componentVariants({ ${api.expectedProps.join(", ")} }), className)}
      {...props}
    />
  );
}
\`\`\`

### Key points:
1. **\`compoundVariants\`** for complex variant combinations
2. **Default values in the function signature**, not in CVA
3. **Always accept \`className\`** for composition
${api.requireRadix ? "4. **Support `asChild`** via Radix Slot\n" : ""}`;
}
